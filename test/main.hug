use std::collections::HashMap;
use std::fs::{
    io,
    vec::Vec as Vector,
    File,
};

pub struct Vec<T> {
    ptr: *Vec<T>,
    tup: (String, path::to::Type, !, ()),
    pub count: u8<Self, fn(!,) -> (!,),>,
}

pub enum Option<T> {
    Some(T,),
    None,
}

type MyResult<T> = Result<T, LongErrorType>;

mod math;
pub mod helpers;

extern {
    type Module;
    pub type Function;

    static COUNTER: u8;
    pub static FLAG: bool;

    fn take<T>(*self, x: u8, y: Vec<T>,) -> T
    where
        T: Fn(u8) -> () + From<T>,
        U: path::to::Trait<> + Clone,
        V = Vec<[usize; 3]>;
}

trait CloneIterator<T>: Clone + Debug
where
    T: Clone + Debug,
{
    fn next(*self) -> Option<T>; 
    fn count(self) -> usize {}
}

fn g<T>(*self) where T: Clone {}
pub fn f(x: u32, _: u64) {
    let Struct { x, y: Some(x, _), .. };
    let path::to::Enum::Variant(S { .. }, _,);
    let []: [u8; 0];
    let (): ();
}

impl Vec<T> where T: Debug {}

impl Vec<T> as Fn(usize) -> T where T: Clone {
    fn call(*self, index: usize) -> T {}
}

fn compose<F, G, A, B, C>(f: F, g: G, a: A) -> C
where
    F: Fn(A) -> B,
    G: Fn(B) -> C,
{}

pub static COUNTER: usize = 1;
static COUNTER: usize = "string";

const BUFFER: [u8; 8] = b"abcdefgh";
const INTS: [i32; 3] = [1, 2, 3];
const TUPLE: (i32, usize) = -((1, 1z,));

impl Vec<T> as Hash where T: Hash {
    fn hash(*self) -> u64 {
        while true { let x = false; };
        1;
    }
}

fn if_else() {
    if 1 {} else if let Some(x) = 3 {} else if true {} else {}
}

fn match_expr() {
    match true {
        Some(x) => false,
        None => loop {}
        Struct { .. } => while false {}
        _ => 1,
        _ => false,
    }
}

fn goto_expr() {
    @start;
    goto @end true;
    goto @end;
    let x = @end;
}

fn struct_expr() {
    let x = path::to::Struct::<u32, Vec<bool>> {
        value,
        count: [""; 6],
        total: local::thing,
    };
}

fn generic_path() {
    let path1 = path::to::Thing;
    let path2 = path::to::Generic::<u8, ()>;
    let path3 = path::To::<u32>::func::<T, U>;
}

fn try_expr() -> Option<u8> {
    let x = x?;
    let y = -y?;
    let z = (-z)?;
    let w = w??;
}

fn range_to() {
    let x = ..1;
    let y = ..;
    let x = ..=2;
    let y = ..=;
}

fn assign_op() {
    let x = x += 1;
    let x = x += x -= 1;
    let x = (x >>= 1) <<= 1;
}

fn arith() {
    let x = 1 + 2 + 3;
    let x = 1 + 2 * 3;
    let x = 1 * 2 + 3;
    let x = 1 + 2 += x += 1 + 2;
}

fn call() {
    f();
    f(x,);
    f(x, y);
    f(x, y, z);
    1 + f(x);
    (1 + 2)(4);
    ..f();

    v as Vec<T>
}

fn ranges() {
    1..2;
    ..2;
    1..;
    ..
}

fn ranges() {
    1..2..3;
    1..self.len();
}